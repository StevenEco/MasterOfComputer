# 进程管理

## 进程的概念

进程是计算机中一个非常重要的概念，在整个计算机发展历史中，操作系统中程序运行机制的演变按顺序大致可以分为：

1. 单道程序：通常是指每一次将一个或者一批程序（一个作业）从磁盘加载进内存，CPU必须等待I/O完成后才可以进行执行，CPU利用率低。
2. 多道程序：讲多个作业调入内存后自动处理，但是单道程序和多道程序均无交互性，可控性差
3. 进程：程序+PCB(状态周期描述)+数据集
4. 线程

### 单道 --> 多道系统

从单道程序演化为多道程序就是CPU的高速与I/O的低速有着显著矛盾，因此引入了多道程序作为解决。举一个例子，在单道程序中，倘若I/O没有完成，那么CPU就会一直处于空闲状态。但是在多道程序中，当某程序在占用CPU的时候，其余程序可以开始进行I/O请求，互不干扰，这样就减少了在I/O中CPU的空闲。当某个程序释放CPU后，下一程序继续占用CPU。

在多道程序中，经常会有这种情况，例如某程序需要监测输入值，那么，该程序就会委托I/O系统去取值，那么在取值完成前，该程序并不需要占用CPU，那么程序会由于I/O阻塞主动放弃CPU，并且进入执行队列尾部，此时CPU会按出队列的顺序依次分配。

多道程序的状态：
![avatar](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225152507QQ20200225-232414@2x.png)

多道程序的调度
![avatar](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225152518QQ20200225-232426@2x.png)

### 多道程序 --> 进程

进程就是在程序中加入一些描述程序状态的块（PCB)

从多道程序演化为进程的过程中是通过提高**并发性**，从而进一步的提高CPU的利用率。事实上也就是在多道程序死板的调度机制中灵活的进行控制程序运行的顺序等。实现的功能便是PCB的监控。

进程的状态：
![avatar](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225154932QQ20200225-234901@2x.png)

进程的调度：
![avatar](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225152449QQ20200225-232341@2x.png)

### 进程 --> 线程

在进程之下，我们引入了线程。在说线程之前，我们引入那么一个问题，假定你制作了一个即时通讯的程序，如果你只是用一个进程去控制程序运行，会发生什么？事实上这里发生的事情你有时候可以在一些小厂商做出的低劣游戏中发现这一问题。我们在有些制作不好、历史久远或者代码质量差的游戏中，经常能发现，一旦网卡了，整个游戏甚至都会卡顿甚至无响应，游戏的渲染也受到了很大的影响。有时候是因为网络一直在尝试发包导致，但是更多时候是因为进程调度问题。可是为什么网络是基于外部的，却可以影响内部的引擎渲染之类的功能呢？原因就是我们之前讲过，请求网络是一个明显的I/O过程，假设网络不好，那么我们的程序一直处于I/O阻塞的状态下，从而放弃CPU，那么我们渲染的代码也会迟迟得不到运行。会到我们之前的问题，假设你只是用一个进程去制作了即时通讯软件，一旦网络丢包之类的网络故障发生时，你的程序很容易卡顿。

说了那么多，我们应该如何去解决这个问题？很自然的我们会想到使用多进程去制作一个软件，那么其中一个进程发生阻塞的时候，我们其余的进程会继续占用CPU，则整体运行并不会受太大影响。但是这种方法需要占用大量的时空，因为进程的调度是依赖PCB以及PCB的监控程序，进程切换过程中，上下文切换也会导致PCB状态切换，需要花费大量的时间进行查询、修改等操作，并且内存栈的使用也会过于频繁导致空间消耗，并且在操作系统中，PCB的数量是有限的，因此使用多进程并不是一个号的方法。

这里我们就引出多线程的方法，**进程就成为了线程的一个容器，且进程和线程可以同时存在**，线程几乎不占用多少空间，整体也比进程小的多，那么对线程的调度开销就会远比进程小得多。进程的数量也减少了，那么整体系统的压力也小了。

## 进程和程序的区别

1. 程序是一段代码编译后的产物，在执行过程中被拷贝至内存，通常是静态不变的，进程在运行过程中是会发生状态转变，通常认为是动态的。进程是对程序一次执行的过程。
2. 程序和进程是多对多关系，例如同时执行两个一样的程序和操作系统的GUI绘图渲染与各个可视化程序的关系。你可以在任务管理器中发现这些关系

## 进程的特征

1. 并发性：与OS的并发一致
2. 异步性：与OS异步一致
3. 动态性：进程在运行过程中是会发生状态转变，通常认为是动态的。
4. 结构性：使用了PCB组成
5. 独立性：在资源分配过程中，各个进程是独立分配。例如各个进程在内存中的位置都是独立的。

## 进程的组成

通常我们只考虑为PCB+程序或PCB+指令段+数据段。这里涉及到的指令段和数据段是什么呢？

指令段就是具体的操作逻辑，而数据段就是存储的具体数据值，他们通常都存储在栈上。例如有一段代码：

``` C#
public int Add()
{
    return 3+4;
}
```

这段代码在进程中会存储函数指针，也就是程序的具体内存位置；3和4将会作为数据段存储在独立的堆栈中，而 ‘+’会存储在指令段中。

### PCB的组成

1. PID：进程的唯一标识
2. 状态：进程五个状态中的一种
3. 优先级：用于控制进程的执行顺序

### 指令段的组成

1. 运行地址：指程序代码在内存中的位置
2. 外存地址：程序在存储设备上中的位置
3. 代码段指针：程序指令段在内存中的具体位置
4. 进入内存时间：进入时间

### 数据段组成

1. 堆栈指针：用于存储数据的地址
2. 数据段指针：数据段代码的地址

进程的组成
![avatar](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_2002251517296F33B270-9B6B-4410-9ADB-7F9C32CC1BE3.png)

## 进程运行分析

对于一个进程或程序需要运行，以下三个东西是必不可少的：

- PCB
- 内存
- CPU

进程的状态：
![avatar](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200225154932QQ20200225-234901@2x.png)

- 对于新建-->就绪过程，进程会向操作系统申请内存和PCB，同时将进程排入队列使得这个非常的简单。
- 就绪-->运行过程，操作系统需要向进程分配CPU资源使得程序运转。反过来则是因为某些原因使得进程不再占用CPU，通常是时间片用完。
- 运行-->阻塞过程，通常是有了一个I/O请求导致了进程的阻塞中断。
- 阻塞-->就绪过程是I/O完成后重新唤起进程，使进程重新进入就绪队列
- 运行-->完成则是归还内存并删除PCB。

在状态转变的时候，通常就是要实施以下三步：

- 分配（申请）内存或CPU
- 回收
- 修改PCB

如果我的文章帮助了你，请给我一个三连和star。

>[Github](https://github.com/StevenEco)
>
>[BiliBili主页](https://space.bilibili.com/33311288)
>
>[WarrenRyan'sBlog](https://blog.tity.xyz)
>
>[博客园](https://cnblogs.com/warrenryan)
